## Урок 1. Лямбды и Stream API

### Термины, используемые в лекции
**Лямбда** — это функция, которая принимает один аргумент и возвращает значение. Она используется для создания анонимных функций в языке программирования Java. Лямбда выражения позволяют создавать функции без создания отдельного класса или метода. Они используются для обработки коллекций данных, отправки событий в обработчики и других задач.

**Stream API** - это библиотека для работы с потоками данных в Java. Она предоставляет множество методов для обработки коллекций, таких как фильтрация, сортировка, преобразование и т.д. Stream API позволяет писать более компактный и эффективный код, а также улучшает его читаемость.

### Лямбда выражения
Лямбда - это функция, описывающая обработку данных, и оно очень похоже на метод. Однако его можно передавать как аргумент. Существует множество классов, методы которых ожидают именно лямбда-выражения в качестве аргументов. Наиболее распространенные из них реализованы в интерфейсе Stream API. Работа этого интерфейса заключается в подборе функций для обработки имеющихся данных, поэтому мы начнем наше обучение с рассмотрения лямбда-выражений и только потом перейдем к изучению Stream API.
```java
public class PlainClass {
    public static void main(String[] args) {
    PlainInterface anInterface = (x, y) -> String.valueOf(x + y);
    System.out.println(anInterface.action(5, 5));
}

@ FunctionalInterface
interface PlainInterface{ String action(int x, int y); }
```

Изменился синтаксис, и код стал проще. Не нужно создавать экземпляр класса, не нужна аннотация оверрайд и, если посмотреть внимательней, мы не передаем типы параметров и не указываем ключевое слово return. Всё это делает компилятор! Ну и если говорить о мелочах, не нужно оборачивать реализацию в фигурные скобки и завершать её точкой с запятой. Однако фигурные скобки, ограничивающие блок кода, не нужны только если реализация умещается в одну строку. Если же вы захотите многострочную реализацию, то и фигурные скобки и return вернутся на свои места. Это чуть больше похоже на классическую реализацию, однако всё же короче и лаконичней! И ещё обращу ваше внимание на новую аннотацию @FunctionalInterface. Она проверяет, является ли интерфейс функциональным, то есть описывает всего один метод. Это обязательно для лямбда выражений и если это не так, аннотация просто не даст коду собраться.

Лямбда создаются на основе функциональных интерфейсов и позволяют переопределить поведение непосредственно в коде, упрощая синтаксис. Они значительно облегчают написание кода, делают его короче и понятнее, напоминая нам о синтаксическом сахаре. Лямбда позволяют использовать преимущества функционального программирования на полностью объектно-ориентированном языке Java.
- Лямбды формируются на основе функционального интерфейса и могут переопределять поведение прямо в коде с упрощенным синтаксисом.
- Лямбды сильно упрощают программирование, делают код проще и короче! И этим напоминают синтаксический сахар.
- Лямбды, являясь функциями, позволяют использовать в полностью объектно-ориентированном языке программирования Java плюсы из функционального программирования. В частности передавать и хранить сами реализации методов!

### Stream API
Название интерфейса намекает на потоки ввода-вывода или на многопоточность, но в Stream API «поток» — это просто набор данных, а интерфейс позволяет нам обрабатывать эти данные с помощью нужных нам функций. Функции передаются в виде лямбда-выражений в качестве параметров, а обработка выполняется последовательно. В Stream API такая последовательность называется «конвейером». Подбирая нужные функции для обработки данных, мы строим конвейер — гибкий, быстрый и легко расширяемый. Конвейеры состоят из методов интерфейса, а сами методы делятся на три типа: генераторы, фильтры и коллекционеры. Но давайте взглянем на простой пример.

```java
List<String> myList = Arrays.asList("Привет", "мир", "!", "Я", "родился", "!");
myList.stream().filter(s -> s.length() > 4).forEach(System.out::println);
```

Первая строка довольно проста и просто создает список строк myList с использованием метода asList класса-помощника Arrays. Но вторая строка интереснее! В Java 8 списки и множества получили новый метод stream(). Его вызов создает обычный поток данных. Можно назвать этот метод “генератором потока”. Теперь у нас есть поток, и мы можем преобразовать его в конвейер, добавив фильтр! Метод filter() является фильтром! Точнее, их правильнее называть промежуточными методами или методами конвейера, поскольку не все из них имеют слово “фильтр” в названии! Как я говорил ранее, в качестве параметра конвейерному методу я передал лямбда-выражение. Мне не нужно объявлять функциональный интерфейс или выполнять еще какие-либо действия, сам метод ожидает лямбда-выражение в качестве параметра! У него уже есть данные, остается описать, что с ними делать. Однако для лямбда-выражений существуют два ограничения. Во-первых, они должны быть невмешивающимися (non-interfering), т. е. не менять исходных данных. Во-вторых, они не должны запоминать состояние (stateless), т.е. не зависеть от порядка выполнения, от внешних переменных и от всего внешнего пространства в целом!

Вы можете создавать потоки с помощью Stream.of, что иногда может быть более удобным. Однако это еще не все, поскольку Stream API также позволяет создавать специализированные потоки для работы с примитивными типами: IntStream, LongStream и DoubleStream. Поток IntStream можно использовать подобно обычному циклу for(;;), используя метод range  
`IntStream.range(1, 4);`  
У таких, вспомогательных, потоков есть пару дополнительных методов таких как sum() и average().  
`IntStream.range(1, 4).average().ifPresent(System.out::println);`

Выводит в консоли среднее значение чисел от 1 до 3. Разобравшись с источниками, переходим к следующему этапу. Важно не только создать поток, но и уметь с ним работать. Здесь мы рассмотрим конвейерные методы, созданные специально для обработки данных в потоке. И здесь есть одна особенность. Они работают по принципу “ленивой” обработки данных! Я буду обращать ваше внимание на эту особенность по мере чтения лекции, чтобы вы могли оценить все преимущества такого подхода. Один Stream может иметь сколько угодно конвейерных операций, и только одну терминальную. Терминальными я буду называть методы-коллекторы по той же причине, по которой конвейерные методы лучше называть промежуточными. Не все коллекторы содержат в своем названии слово “collect”!. Третью часть лекции мы посвятим терминальным методам, но если Stream с конвейерными операциями не завершить терминальной операцией, никаких действий выполнено не будет. Это связано с тем, что я как программист не просил программу сохранять результаты ее работы. Зачем выполнять работу, если результат не будет использован? Это одна из ключевых особенностей “ленивого” подхода. До тех пор пока мы не перейдем к рассмотрению терминальных методов, будем использовать forEach() в качестве примера.
```java
List<String> list = Arrays.asList("Не", "заменят", "край", "родимый", "Никакие", "чудеса!", "Только", "здесь", "всё", "так", "любимо", "Реки", "горы", "и", "леса.");
list.stream().filter(n -> n.length() > 4).forEach(n -> System.out.print(n + " "));
```

Мы подготовили список данных в первой строке и создали поток со встроенным фильтром во второй строке. Фильтр проверяет длину строки, которая должна быть не менее четырех букв. В терминальном методе мы просто выводим результат в консоль. Результат верен только для слов длиной больше четырех символов. Однако мы написали исходный код не очень аккуратно. Обычно при использовании Stream API вызовы методов размещаются на отдельных строках.
```java
list.stream()
    .filter(n -> n.length() > 4)
    .forEach(n -> System.out.print(n + " "));

list.stream()
    .filter(n -> n.length() > 4)
    .filter(c -> c.toLowerCase().contains("а"))
    .forEach(n -> System.out.print(n + " "));
```

Мы добавили одну строку, и все слова, которые не содержат букву “а”, исчезли. Здесь есть одна особенность: в лямбде мы использовали метод toLowerCase(), который возвращает строку в нижнем регистре, но результат остался в исходном регистре. Дело в том, что filter, как и следует из его названия, не изменяет исходные данные, а только выбирает необходимые, удовлетворяющие условию, описанному в лямбде. Это очень удобно, в частности, тем, что при написании условий можно не беспокоиться о целостности исходных данных. Следующим идет конвейерный метод skip, который позволяет пропустить заданное количество первых элементов потока
```java
list.stream()
    .skip(list.size() / 2)
    .forEach(n -> System.out.print(n + " "));
```
Мы пропустили первую половину данных потока и работать начали только со второй! Давайте объединим filter и skip
```java
list.stream()
    .skip(list.size() / 2)
    .filter(n -> n.length() > 4)
    .filter(n -> n.toLowerCase().contains("а"))
    .forEach(n -> System.out.print(n + " "));
```

```java
list.stream()
    .limit(list.size() / 2)
    .filter(n -> n.length() > 4)
    .filter(n -> n.toLowerCase().contains("а"))
    .forEach(n -> System.out.print(n + " "));
```
Тот же код, но skip поменяем на limit. Ну и результат совсем другой! Теперь выборка из первой половины. Метод простой поэтому переходим к следующему. Distinct, тут тоже всё просто, он пропускает поток без повторов.
```java
List<String> list = Arrays.asList("а", "б", "а", "в", "а", "г", "а", "д");

list.stream()
    .distinct()
    .forEach(n -> System.out.print(n));
```