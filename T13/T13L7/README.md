## Урок 7. Spring Security. Работа с JWT. Защита от основных видов атак

### <u>Термины, используемые в лекции</u>

**Spring Security** – это мощный и настраиваемый механизм безопасности для приложений Spring, позволяющий интегрировать различные средства аутентификации и авторизации.

**JWT (JSON Web Token)** – это компактное, URL-безопасное средство представления между двумя сторонами. Они обычно используются для передачи данных аутентификации и авторизации.

**Bearer Token** – тип токена авторизации, который предоставляется клиентом при каждом запросе. Это часто JWT.

**Authentication (Аутентификация)** – процесс определения, кто вы.

**Authorization (Авторизация)** – процесс определения, что вам разрешено делать.

**OAuth2** – протокол авторизации, который позволяет приложениям получать ограниченный доступ к аккаунтам пользователя на внешних сервисах.

**CSRF (Cross-Site Request Forgery)** – вид атаки, при которой злоумышленник может заставить пользователя выполнить нежелательное действие в веб-приложении, в котором он аутентифицирован.

**CORS (Cross-Origin Resource Sharing)** – механизм, который позволяет разрешить или запретить веб-страницам выполнение запросов к серверу с другого источника.

**XSS (Cross-Site Scripting)** – вид атаки, при которой злоумышленник может вставить злонамеренный код в веб-страницы

**SQL Injection** – вид атаки, при которой злоумышленник может выполнять произвольные SQL-запросы в базе данных через вводимые пользователем данные.

**Principal** – текущий пользователь или системный процесс, который выполняет действие в системе.

**Role-Based Access Control (RBAC)** – метод определения доступа на основе ролей пользователей в системе.

**Filter Chain** – цепочка фильтров в Spring Security, которая обрабатывает входящие HTTP-запросы для выполнения различных задач безопасности.

**Authentication Provider** – компонент в Spring Security, который определяет, как пользователи будут аутентифицированы.

### <u>Важность информационной безопасности</u>

Итак, давайте начнем с простого вопроса: почему информационная безопасность так важна для серверных приложений? На этот вопрос есть довольно простой ответ: данные. Каждое серверное приложение обрабатывает данные, а в некоторых случаях эти данные могут быть чрезвычайно ценными. Это могут быть личные данные пользователей, финансовые данные, секретные корпоративные документы, и так далее.

Если эти данные попадут в неправильные руки из-за недостаточной безопасности нашего серверного приложения, последствия могут быть катастрофическими. Мы говорим о возможных штрафах за нарушение законов о защите данных, потере доверия со стороны клиентов, ущербе для репутации компании и многом другом. 

Помимо этого, если наше приложение является частью большей системы, например, микросервисной архитектуры, то уязвимость в одном приложении может стать угрозой для всей системы. Например, злоумышленник, получивший доступ к одному сервису, может использовать его в качестве “трамплина” для атаки на другие сервисы.

В общем, игнорирование вопросов информационной безопасности может привести к серьезным последствиям. Именно поэтому каждый разработчик должен знать основы безопасности и применять их на практике.

Может быть, немного сложно понять абстрактные опасности, связанные с игнорированием вопросов безопасности, поэтому давайте посмотрим на несколько реальных примеров нарушения безопасности и их последствий.

Один из самых известных примеров - это компания Yahoo. В 2013 году они были жертвой крупнейшего в истории нарушения безопасности, которое затронуло около 3 миллиардов пользовательских аккаунтов. Воры получили доступ к именам, адресам электронной почты, номерам телефонов, датам рождения и, в некоторых случаях, зашифрованным паролям. В итоге Yahoo была вынуждена выплатить $50 млн в качестве компенсации своим пользователям.

Еще один пример – это компания Equifax, одна из трех крупнейших кредитных бюро в США. В 2017 году злоумышленники получили доступ к личным данным около 147 миллионов людей, включая имена, номера социального страхования, даты рождения, адреса и номера водительских удостоверений. Это нарушение безопасности обошлось Equifax в $575 миллионов штрафов и выплат по искам.

Эти примеры показывают, что последствия нарушений безопасности могут быть дорогостоящими и разрушительными для бизнеса. Именно поэтому так важно уделять должное внимание безопасности в процессе разработки серверных приложений.

### <u>Аутентификация</u>

Одним из первых шагов для обеспечения безопасности нашего серверного приложения является понимание и применение аутентификации. Аутентификация - это процесс подтверждения идентичности пользователя. В своей основе это ответ на вопрос: “Ты действительно тот, за кого ты себя выдаешь?”

Давайте приведем несколько примеров аутентификации, чтобы лучше понять, как она работает.
1. Вход в систему с использованием имени пользователя и пароля: это, возможно, самый распространенный пример аутентификации. Когда вы вводите свое имя пользователя и пароль, система проверяет эти данные, чтобы убедиться, что вы - это вы.
2. Вход с помощью отпечатка пальца или распознавания лица на вашем смартфоне: это пример биометрической аутентификации, где ваши уникальные физические характеристики используются для подтверждения вашей личности.
3. Ввод PIN-кода или ответ на секретный вопрос: это еще один способ аутентификации, который часто используется в банковских системах или системах восстановления паролей.

Все эти примеры являются формами аутентификации, и все они имеют общую цель – убедиться, что пользователь, пытающийся получить доступ к системе, действительно является тем, кем он утверждает быть. Это важный первый шаг для обеспечения безопасности нашего серверного приложения.

### <u>Авторизация</u>

Теперь, когда мы знаем, кто наш пользователь благодаря аутентификации, следующий шаг – это определить, что он может делать в нашей системе. Здесь на сцену выходит авторизация.

Авторизация – это процесс, в рамках которого определяется, какие действия разрешены пользователю в системе. Если аутентификация отвечает на вопрос “кто?”, то авторизация отвечает на вопрос “что может?”.

Давайте рассмотрим примеры авторизации в реальной жизни:
1. В компьютерной игре пользователь может быть аутентифицирован как игрок, но авторизован только для выполнения определенных действий, таких как перемещение персонажа, использование предметов, но не для изменения параметров игры или добавления новых уровней.
2. В банковской системе клиент может быть аутентифицирован как владелец счета, но авторизован только для выполнения операций, таких как проверка баланса, совершение платежей, но не для увеличения баланса счета без выполнения денежного перевода.
3. В интернет-магазине покупатель может быть аутентифицирован как зарегистрированный пользователь, но авторизован только для просмотра товаров, добавления их в корзину, совершения покупки, но не для изменения цен на товары или добавления новых товаров в каталог.

Как видите, авторизация является важным элементом безопасности серверных приложений, потому что она позволяет контролировать доступ пользователя к функциям и данным приложения.

### <u>Принципы безопасности</u>

Когда мы говорим о безопасности серверных приложений, существует несколько ключевых принципов, которые мы должны учесть. Они определяют наш подход к обеспечению безопасности и помогают нашим приложениям оставаться защищенными от угроз.
1. Минимальные привилегии: Принцип минимальных привилегий говорит о том, что каждый пользователь (или процесс) должен иметь минимально необходимые права для выполнения своих функций. Это означает, что пользователи не должны иметь доступа к функциям или данным, которые они не нуждаются для выполнения своих задач. Это прямо связано с авторизацией, о которой мы говорили ранее.
2. Защита данных: Данные, особенно чувствительные, такие как личная информация пользователей, должны быть защищены во все время. Это может включать в себя шифрование данных, использование безопасных протоколов передачи данных и обеспечение безопасного хранения данных.
3. Аудит и мониторинг: Всегда важно иметь возможность отслеживать и анализировать действия в вашем приложении. Это может помочь выявить подозрительную активность и быстро реагировать на возможные угрозы.
4. Обработка ошибок и исключений: Неправильная обработка ошибок может привести к утечке информации, которая может быть использована злоумышленниками. Важно убедиться, что ваше приложение корректно обрабатывает ошибки и исключения, не раскрывая лишней информации.
5. Обновления и патчи: Уязвимости и ошибки безопасности могут появляться в любой системе. Поэтому важно регулярно обновлять и применять патчи к вашему приложению и его зависимостям.

Все эти принципы вместе обеспечивают многоуровневую защиту для вашего приложения и помогают снизить риск нарушения безопасности.

### <u>Важность принципов</u>

Серверное приложение без применения вышеупомянутых принципов безопасности – это как автомобиль без замка и страховки. Да, он может ездить, но в любой момент его могут украсть или он может попасть в аварию, и вы останетесь ни с чем. Поэтому, когда мы разрабатываем серверное приложение, мы не можем просто игнорировать эти принципы безопасности.

Понимание и применение принципов минимальных привилегий, защиты данных, ограничения доступа и защиты от атак – это не просто “хорошая практика”. Это абсолютная необходимость.

Без аутентификации и авторизации мы не сможем гарантировать, что пользователи нашего приложения - это те, за кого они себя выдают, и что они могут делать только то, что допустимо в рамках их привилегий. Без защиты данных мы рискуем потерять или раскрыть важную информацию. Без защиты от атак мы становимся легкой мишенью для злоумышленников.

Подводя итог, понимание и применение этих принципов безопасности - это ключ к созданию надежных и защищенных серверных приложений. Это то, что отделяет профессиональных разработчиков от новичков. И это то, что мы сегодня учимся делать.

### <u>Что такое Spring Security</u>

Теперь, когда мы разобрали основные понятия и принципы безопасности, давайте поговорим о том, что же такое Spring Security и как он может нам помочь.

Spring Security – это фреймворк безопасности для Java-приложений. Представьте его как высокотехнологичный охранник, который следит за входами и выходами в ваш замок (ваше приложение) и следит за тем, чтобы все гости (пользователи) вели себя прилично.

Основные компоненты Spring Security - это:
1. Аутентификация: Как мы обсуждали ранее, аутентификация - это процесс проверки личности пользователя. Spring Security предоставляет широкий спектр механизмов аутентификации, таких как форма входа, LDAP, OAuth и другие.
2. Авторизация: После того, как пользователь аутентифицирован, Spring Security контролирует доступ к различным частям приложения. Это можно настроить на уровне URL или методов, обеспечивая гибкий и мощный механизм контроля доступа.
3. Защита от атак: Spring Security также обеспечивает защиту от самых распространенных типов атак, таких как CSRF (межсайтовая подделка запроса), XSS (межсайтовый скриптинг) и Session Fixation.
4. Шифрование паролей: Spring Security поддерживает различные механизмы шифрования паролей, что помогает обеспечить безопасное хранение и обработку паролей.

Все эти компоненты вместе образуют мощный инструмент для обеспечения безопасности вашего серверного приложения. По сути, Spring Security управляет всей политикой безопасности вашего приложения, обеспечивая защиту от несанкционированного доступа и атак.

### <u>JSON Web Token (JWT)</u>

Поговорим теперь о том, что такое JSON Web Token или JWT и как он используется в Spring Security.

JWT – это стандарт, который определяет способ безопасной передачи информации между двумя сторонами в виде JSON-объекта. Эта информация может быть подтверждена и доверена, потому что она цифрово подписана. Подумайте об этом как о специальном паспорте для ваших пользователей, который они могут использовать, чтобы доказать, кто они и что они могут делать в вашем приложении.

Так зачем нам это нужно? Ну, в некоторых случаях, особенно когда у нас есть много сервисов, которым нужно обмениваться информацией о пользователе, JWT может быть очень полезен. Вместо того, чтобы каждый раз аутентифицировать пользователя в каждом сервисе, мы можем просто передать этот “паспорт” и сервис сможет узнать, кто этот пользователь и что он может делать.

В Spring Security JWT обычно используется вместе с OAuth 2.0 для аутентификации и авторизации. Схема обычно такова:
1. Пользователь аутентифицируется с помощью своих учетных данных.
2. После успешной аутентификации сервер создает JWT, который содержит уникальные данные пользователя, и отправляет его обратно пользователю.
3. Пользователь сохраняет этот JWT и отправляет его в заголовке Authorization с каждым последующим запросом.
4. Сервер проверяет JWT в каждом запросе, чтобы аутентифицировать пользователя и определить его права доступа.

В целом, JWT предоставляет нам способ безопасного обмена информацией между сервером и клиентом, что является важной частью безопасности нашего серверного приложения.

### <u>Настройка Spring Security</u>

**Шаг 1: Добавление зависимости**

Первое, что нам нужно сделать - добавить зависимость Spring Security в наш проект. Если вы используете Maven, вам нужно добавить следующую зависимость в ваш pom.xml:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

**Шаг 2: Создание класса конфигурации безопасности**

Затем мы должны создать класс, который будет конфигурировать наши настройки безопасности. Этот класс должен быть аннотирован @EnableWebSecurity и расширять WebSecurityConfigurerAdapter. Вот пример:
```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .anyRequest().authenticated()
            .and()
            .httpBasic();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth
            .inMemoryAuthentication()
            .withUser("user").password(passwordEncoder().encode("password")).roles("USER");
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
В этом классе мы говорим Spring Security, что мы хотим аутентифицировать любой запрос и использовать базовую HTTP аутентификацию. Мы также настраиваем в памяти аутентификацию с одним пользователем.

**Шаг 3: Тестирование нашей конфигурации безопасности**

Теперь, когда у нас есть настройки безопасности, мы можем их протестировать. Для этого мы можем создать простой контроллер, который возвращает какой-нибудь текст, и попробовать получить доступ к нему.
```java
@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, world!";
    }
}
```

Теперь, если вы попытаетесь открыть http://localhost:8080/hello в браузере, вы должны увидеть диалоговое окно, запрашивающее имя пользователя и пароль.

Если вы введете имя пользователя “user” и пароль “password”, вы должны увидеть сообщение “Hello, world!”.

Вот и все! Вы только что настроили Spring Security в своем Spring проекте. Конечно, это очень простой пример, и в реальном проекте вам потребуется более сложная конфигурация. Но это хорошая отправная точка для начала работы с Spring Security.

### <u>Различные виды атак</u>

Давайте рассмотрим некоторые из самых распространенных типов атак, которые мы можем столкнуться при разработке серверных приложений, и узнаем, как Spring Security помогает нам противостоять этим угрозам.
1. CSRF (межсайтовая подделка запроса): Это атака, при которой злоумышленник заставляет жертву выполнить нежелательные функции на веб-сайте, в котором они аутентифицированы. Spring Security предотвращает атаки CSRF, используя синхронный маркер, который проверяется с каждым запросом на изменение состояния.
2. XSS (межсайтовый скриптинг): Это атака, при которой злоумышленник вставляет злонамеренный скрипт в веб-страницу, который затем выполняется в браузере жертвы. Хотя защита от XSS обычно включает эскейпинг и проверку входных данных на стороне сервера и клиента, Spring Security предоставляет дополнительные заголовки безопасности, которые помогают защитить от определенных видов атак XSS.
3. SQL-инъекции: Это атака, при которой злоумышленник вставляет злонамеренные SQL-запросы в ввод пользователя, который затем выполняется в базе данных. В то время как защита от SQL-инъекций в основном связана с валидацией входных данных и использованием параметризованных запросов или ORM, Spring Security также помогает уменьшить риск, обеспечивая хорошие практики аутентификации и авторизации.
4. Атаки с перехватом сессии (Session Hijacking): Злоумышленник может попытаться перехватить сессию пользователя и использовать ее для доступа к системе. Spring Security предоставляет механизмы для управления и защиты сессий, включая защиту от фиксации сессии и механизмы для автоматического выхода из системы.

Это только некоторые из атак, которые Spring Security помогает нам противостоять. Помните, безопасность - это не одноразовое действие, а процесс. Всегда следите за новыми угрозами и лучшими практиками в области безопасности.

### <u>Практика</u>

**Общая информация**

Целью этого задания является разработка серверного приложения с использованием Spring Security и JSON Web Tokens (JWT) для аутентификации и авторизации пользователей.

**Технические требования**

1. Spring Boot: Приложение должно быть разработано на Spring Boot.
2. Spring Security: Должна быть настроена аутентификация и авторизация с использованием Spring Security.
3. JWT: При успешной аутентификации, сервер должен создавать JWT, который включает в себя идентификационные данные пользователя, и отправлять его клиенту. JWT должен использоваться для аутентификации пользователей в последующих запросах.
4. База данных: Приложение должно включать базу данных для хранения информации о пользователях. База данных может быть любой по вашему выбору (например, MySQL, PostgreSQL, MongoDB и т.д.).
5. REST API: Приложение должно предоставлять REST API, который позволит пользователям регистрироваться (создавать новые учетные записи) и входить в систему (аутентификация).

**Функциональные требования**
1. Регистрация: Пользователи должны иметь возможность регистрироваться, указывая свое имя, электронную почту и пароль.
2. Аутентификация: Пользователи должны иметь возможность входить в систему, используя свой адрес электронной почты и пароль. При успешной аутентификации сервер должен генерировать JWT и отправлять его пользователю.
3. Авторизация: После аутентификации пользователи должны иметь доступ к защищенным ресурсам в соответствии с их ролями. Это должно быть обеспечено с помощью JWT, полученного при аутентификации.
4. Обработка JWT: Сервер должен быть способен обрабатывать JWT в каждом запросе, чтобы аутентифицировать пользователя и определить его права доступа.

**Создание проекта**

Отлично, давайте перейдем к реализации! Для начала нам нужно создать новый проект Spring. Мы будем использовать Spring Initializr, который упростит этот процесс.

**Шаг 1: Создание проекта в Spring Initializr**

1. Откройте Spring Initializr.
2. Выберите “Maven Project” в качестве типа проекта.
3. В качестве языка программирования выберите “Java”.
4. Выберите последнюю версию Spring Boot.
5. Введите детали проекта. В качестве Group, введите что-то вроде “com.yourname”. В Artifact, введите что-то вроде “jwt-demo”.
6. В качестве упаковки выберите “Jar”.
7. Выберите версию Java, которую вы используете.
8. В разделе “Dependencies” добавьте следующие зависимости: “Spring Web”, “Spring Security”, “Spring Data JPA” (для работы с базой данных) и “JJwt” (библиотека для работы с JWT).
9. Нажмите “Generate”, чтобы скачать проект.

**Шаг 2: Открытие проекта в IDE**

Теперь, когда у вас есть сгенерированный проект, вы можете открыть его в вашей любимой IDE (например, IntelliJ IDEA, Eclipse и др.). Все настройки уже выполнены автоматически, и вы можете начать разработку вашего приложения.

**Шаг 3: Добавление зависимости для JWT**

Хотя мы уже добавили большую часть необходимых зависимостей через Spring Initializr, нам все еще нужно добавить зависимость для работы с JWT. Откройте ваш pom.xml и добавьте следующую зависимость:
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>
```
Теперь у нас есть все необходимые зависимости, и мы готовы начать разработку нашего приложения с использованием Spring Security и JWT!

### <u>Настройка Spring Security</u>

Далее нам нужно настроить Spring Security в нашем проекте. Это позволит нам контролировать доступ к нашему приложению и защищать его от несанкционированного доступа.

**Шаг 1: Создание класса конфигурации безопасности**

Сначала создадим класс конфигурации безопасности. Этот класс будет определять, какие запросы должны быть защищены. Давайте назовем этот класс SecurityConfig и сделаем его расширяющим WebSecurityConfigurerAdapter.
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    // Детали настройки будут добавлены позже
}
```
Здесь @Configuration и @EnableWebSecurity - это аннотации Spring, которые говорят, что этот класс является конфигурационным классом и что он должен использоваться для настройки безопасности нашего приложения.

**Шаг 2: Настройка правил безопасности**

Теперь мы можем добавить наши правила безопасности в класс SecurityConfig. Это делается путем переопределения метода configure и указания настроек безопасности с помощью HttpSecurity объекта:
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable() // Отключаем защиту CSRF, так как будем использовать JWT
        .authorizeRequests()
        .antMatchers("/login").permitAll() // Позволяем всем пользователям доступ к эндпоинту "/login"
        .anyRequest().authenticated() // Все остальные эндпоинты требуют аутентификации
        .and()
        .addFilter(new JwtAuthenticationFilter(authenticationManager())) // Добавляем наш фильтр аутентификации
        .sessionManagement()
        .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // Не создаем сессию, так как будем использовать JWT
}
```

**Шаг 3: Создание фильтра аутентификации**

Как видно из предыдущего шага, мы добавляем фильтр JwtAuthenticationFilter в конвейер безопасности. Этот фильтр будет обрабатывать запросы на эндпоинт “/login” и создавать JWT для аутентифицированных пользователей.
```java
public class JwtAuthenticationFilter extends UsernamePasswordAuthenticationFilter {
    // Детали реализации будут добавлены позже
}
```
В этом классе нам нужно переопределить метод attemptAuthentication для обработки учетных данных пользователя и метод successfulAuthentication для создания JWT после успешной аутентификации.

Так, мы настроили базовую структуру безопасности нашего приложения. В следующих шагах мы рассмотрим, как создать сервис для работы с пользовательскими данными и как работать с JWT.

### <u>Обработка JWT</u>

**Шаг 1: Генерация JWT**

Вернемся к нашему классу JwtAuthenticationFilter. После успешной аутентификации
нам нужно генерировать JWT и добавлять его в ответ. Это делается путем
переопределения метода successfulAuthentication. Вот как это можно сделать:
```java
@Override
protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
    UserDetails principal = (UserDetails) authResult.getPrincipal();
    String token = Jwts.builder()
        .setSubject(principal.getUsername())
        .setExpiration(new Date(System.currentTimeMillis() + JwtProperties.EXPIRATION_TIME)) // Устанавливаем срок действия токена
        .signWith(SignatureAlgorithm.HS512, JwtProperties.SECRET) // Подписываем токен нашим серверным секретом
        .compact();
    response.addHeader(JwtProperties.HEADER_STRING, JwtProperties.TOKEN_PREFIX + token); // Добавляем токен в заголовок ответа
}
```
JwtProperties - это просто класс, содержащий константы, связанные с JWT, такие как строка заголовка (“Authorization”), префикс токена (“Bearer”), секрет и время истечения токена.

**Шаг 2: Проверка JWT**

Теперь, когда у нас есть JWT, мы можем использовать его для аутентификации пользователей в последующих запросах. Для этого нам нужно создать еще один фильтр, который будет проверять JWT в заголовках запросов.
```java
public class JwtAuthorizationFilter extends BasicAuthenticationFilter {

    public JwtAuthorizationFilter(AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        // Здесь будет код для проверки JWT
    }
}
```
В методе doFilterInternal нам нужно извлечь JWT из заголовка, проверить его и установить аутентификацию для текущего контекста безопасности, если токен действителен.

**Шаг 3: Добавление фильтра авторизации в конфигурацию безопасности**

После создания JwtAuthorizationFilter нам нужно добавить его в нашу конфигурацию
безопасности. Это делается путем добавления фильтра перед фильтром
UsernamePasswordAuthenticationFilter в нашем классе SecurityConfig.
```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .addFilter(new JwtAuthenticationFilter(authenticationManager()))
        .addFilterBefore(new JwtAuthorizationFilter(authenticationManager()), UsernamePasswordAuthenticationFilter.class);
    // Остальной код конфигурации
}
```
Теперь наша настройка безопасности полностью готова! У нас есть процесс аутентификации, который генерирует JWT, и процесс авторизации, который проверяет JWT и предоставляет доступ к защищенным ресурсам.

### <u>Реализация – защита от атак</u>
В мире веб-разработки мы постоянно сталкиваемся с различными видами атак, и Spring Security предлагает нам несколько механизмов для их предотвращения.

**Защита от CSRF-атак**

CSRF (Cross-Site Request Forgery) - это атака, которая заставляет пользователя выполнить действие, которого он не собирался делать. Чтобы предотвратить эти атаки, Spring Security предоставляет защиту от CSRF по умолчанию.
В нашем случае, при использовании JWT, защиту CSRF можно отключить, поскольку каждый запрос должен иметь валидный токен, что делает CSRF атаки практически невозможными. Мы уже отключили CSRF в нашем классе конфигурации: `http.csrf().disable()`

**Защита от XSS-атак**

XSS (Cross-Site Scripting) - это атака, при которой злоумышленник вставляет злонамеренные скрипты в веб-страницы, просматриваемые другими пользователями. Spring Security предлагает механизмы защиты от XSS через HTTP-заголовки безопасности.

В нашем классе конфигурации безопасности мы можем добавить следующие заголовки для защиты от XSS: `http.headers().contentSecurityPolicy("script-src 'self'")`

**Защита от SQL Injection**

SQL Injection - это атака, при которой злоумышленник может вставлять злонамеренные SQL запросы в поля ввода формы. Защита от таких атак обычно связана с валидацией входных данных и использованием параметризованных запросов. Spring Data JPA автоматически защищает вас от SQL-инъекций, используя параметризованные запросы и безопасные методы API, такие как CrudRepository#save, CrudRepository#findOne и т.д.

**Защита от атак Session Fixation**

Session Fixation - это атака, при которой злоумышленник использует сессию, которую пользователь уже открыл, для получения несанкционированного доступа. В Spring Security есть множество стратегий для борьбы с атаками Session Fixation, включая создание новой сессии при входе в систему, что является поведением по умолчанию.

Кроме того, использование JWT еще больше уменьшает риск атак Session Fixation, поскольку информация о сессии не хранится на сервере.

### <u>Проверка результата</u>

После реализации всех частей нашего приложения, важно убедиться, что все работает корректно. Ниже представлены некоторые сценарии для проверки работоспособности вашего приложения.

**Проверка аутентификации и обработки JWT**
1. Регистрация нового пользователя: При отправке запроса на регистрацию с валидными данными, вы должны получить ответ с успешным статусом. При повторной отправке того же запроса, вы должны получить ошибку, указывающую на то, что пользователь с таким адресом электронной почты уже существует.
2. Вход в систему: При отправке запроса на вход с валидными учетными данными, вы должны получить JWT в заголовке ответа. Если вы отправите неверные учетные данные, вы должны получить сообщение об ошибке.
3. Доступ к защищенному ресурсу: Если вы попытаетесь получить доступ к защищенному ресурсу без JWT или с недействительным JWT, вы должны получить сообщение об ошибке. Если вы отправите запрос с действительным JWT, вы должны получить ожидаемый ответ.

**Проверка защиты от атак**
1. CSRF-атака: Попытайтесь выполнить запрос на изменение состояния без CSRF-токена или с недействительным CSRF-токеном. Вы должны получить сообщение об ошибке.
2. XSS-атака: Попытайтесь вставить злонамеренный скрипт в одно из полей ввода формы. Злонамеренный скрипт не должен быть выполнен.
3. SQL-инъекция: Попытайтесь вставить злонамеренный SQL-запрос в одно из полей ввода формы. Запрос не должен быть выполнен и должно быть возвращено сообщение об ошибке.
4. Атака Session Fixation: Попытайтесь использовать старую сессию после входа в систему. Вы должны получить сообщение об ошибке, указывающее, что сессия недействительна.

Помимо этих проверок, рекомендуется написать автоматические тесты для проверки различных сценариев работы вашего приложения. Это может включать в себя unit-тесты для отдельных компонентов, интеграционные тесты для проверки взаимодействия компонентов и end-to-end тесты для проверки работы всего приложения в целом.
