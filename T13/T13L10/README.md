## Урок 10. Spring Testing. JUnit и Mockito для написания тестов

### Термины, используемые в лекции

**Spring Test Context Framework** — инфраструктура Spring для тестирования Spring-компонентов с JUnit или TestNG.

**@SpringBootTest** — аннотация, используемая для указания, что тестовый класс является тестом Spring Boot. Это помогает в автоматической настройке Spring Application Context.

**JUnit** — это библиотека Java для юнит-тестирования.

**@Test** — аннотация JUnit, указывающая, что метод является тестовым методом.

**Mockito** — популярная библиотека для создания mock-объектов в Java.

**Mock** — созданный объект, который имитирует поведение реального объекта. Используется в юнит-тестировании для изоляции тестируемого компонента.

**@Mock и @MockBean** — аннотации Mockito, используемые для создания и внедрения mock-объектов.

**@InjectMocks** — аннотация Mockito для создания экземпляра класса и внедрения в него mock-объектов.

**@BeforeEach и @AfterEach** — аннотации JUnit для методов, которые должны выполняться перед и после каждого тестового метода соответственно.

**@BeforeAll и @AfterAll** — аннотации JUnit для методов, которые должны выполняться один раз перед первым тестовым методом и после последнего тестового метода класса соответственно.

**assertThat()** — метод, используемый для утверждений в тестах.

**Matchers** — классы или методы, предоставляемые библиотеками тестирования (например, Mockito или Hamcrest), чтобы помочь в формировании утверждений.

**Test Runner** — класс или инструмент, который управляет запуском тестов и обеспечивает обратную связь о результатах.

**ApplicationContext** — центральный интерфейс для доступа к конфигурации приложения в Spring.

**@ContextConfiguration** — аннотация, используемая для указания конфигурации ApplicationContext для тестов.

**@ActiveProfiles** — аннотация для установки активных профилей Spring в тестах

### История тестирования программного обеспечения

Друзья, вы когда-нибудь задумывались, почему мы так усердно тестируем свой код? Давайте вернемся немного назад во времени и узнаем, как всё началось.

В начале компьютерной эры, когда компьютеры были размером с комнату, и их задачей было выполнить несколько математических операций, тестирование не было таким актуальным. Программы были относительно простыми, и их легко было проверить вручную. Но по мере развития технологий, программы становились все сложнее и многозадачнее, и “надеяться, что всё будет ок” уже не катило.

К середине 20-го века, с ростом сложности ПО и появлением первых операционных систем, стало понятно, что нужен какой-то способ проверки качества программ. Ошибки в коде могли привести к дорогостоящим последствиям, будь то финансовые потери или даже угроза жизни, в случае промышленного или медицинского оборудования.

Так, в 1960-х годах, с появлением методологий разработки ПО, таких как водопадная модель, тестирование стало важным этапом в процессе разработки. Оно обеспечивало подтверждение того, что ПО соответствует требованиям и работает корректно.

А затем пришли методологии Agile и DevOps, которые сделали тестирование не просто этапом, но и неотъемлемой частью процесса разработки. Теперь тестирование стало регулярным, автоматизированным и постоянным. Современные инструменты, такие как JUnit и Mockito, которыми мы сегодня будем заниматься, делают тестирование быстрым, эффективным и надежным.

Баги — это не просто недоразумения, которые можно легко исправить. Иногда они могут стоить компаниям миллионов долларов, портить репутацию или даже вызывать катастрофы. Давайте посмотрим на несколько известных случаев, чтобы понять, насколько важно качественное тестирование.
1. Шаттл “Маринер-1”: В 1962 году НАСА потеряло космический корабль стоимостью 80 миллионов долларов из-за одной неверной точки в коде. Корабль ушел с курса и был уничтожен спустя 293 секунды после запуска. Кто бы мог подумать, что одна маленькая ошибка в коде приведет к таким последствиям?
2. Amazon Web Services, 2017: В один не такой уж прекрасный день, часть интернета просто “упала”. Множество сайтов и сервисов, таких как Slack, Trello и даже часть Apple services, столкнулись с проблемами. Причина? Один из инженеров AWS ввел неверную команду, пытаясь отладить систему.
3. Knight Capital Group: Эта торговая компания потеряла 440 миллионов долларов за 45 минут из-за ошибки в своей торговой системе. Эта ошибка стала причиной крупных потерь и почти разрушила компанию.
4. Ошибки в играх: Игры также не застрахованы от багов. Например, в первой версии игры “Assassin’s Creed” персонажи часто “падали” сквозь мир или сталкивались с другими странными проблемами. Все это привело к снижению рейтинга игры и разочарованию игроков.

Подводя итог, каждая из этих ошибок могла бы быть предотвращена с помощью качественного тестирования. Баги - это не просто ошибки в коде. Это потенциальные угрозы вашему бизнесу, репутации и доверию пользователей. Так что давайте не пренебрегать тестами, чтобы избежать таких катастроф в будущем!

### Виды тестов

Давайте кратко рассмотрим основные виды тестирования и поймем, как они дополняют друг друга.
1. Модульные тесты (Unit Tests): Эти тесты фокусируются на самых маленьких частях нашего кода, таких как функции или методы. Они убеждаются, что каждый “кирпичик” нашего ПО работает правильно в изоляции.
2. Интеграционные тесты: Здесь мы проверяем, как эти “кирпичики” работают вместе. Например, правильно ли наше приложение взаимодействует с базой данных или другими службами.
3. Системные тесты: Эти тесты проверяют работу всего приложения в целом. Они удостоверяются, что все компоненты совместно работают корректно и обеспечивают нужный результат для конечного пользователя.
4. Тесты приемки: Тут мы проверяем, соответствует ли наше ПО бизнес-требованиям и ожиданиям пользователей.
5. Нагрузочные тесты: Эти тесты помогают нам понять, как наше приложение справляется с большим количеством запросов или большим объемом данных.

Видите, каждый вид тестирования дополняет друг друга. Пока модульные тесты убеждаются, что каждый компонент работает правильно, интеграционные тесты проверяют, что эти компоненты хорошо взаимодействуют между собой. Системные тесты обеспечивают общую рабочую среду, а нагрузочные тесты гарантируют, что наше приложение готово к реальной жизни.

### Unit-тесты

Unit-тесты — это тесты, написанные для проверки функциональности отдельных частей программы, таких как функции, методы или классы. В идеале, каждый unit-тест должен быть изолированным и проверять только одну вещь.

**Почему они так важны?**
1. Быстрая обратная связь: Поскольку unit-тесты проверяют маленькие части кода, они выполняются быстро, что позволяет разработчикам мгновенно узнать о проблемах.
2. Повышение уверенности: Если ваши unit-тесты зеленые, это означает, что мелкие кирпичики вашего ПО работают, как ожидается.
3. Упрощение изменений: Быстро узнавая об ошибках, можно без страха вносить изменения в код.

**Как писать unit-тесты?**
1. Изолированность: Каждый тест должен быть независимым от других тестов и окружения. Это означает, что тест не должен полагаться на внешние сервисы, базы данных и т.д.
2. Одна проверка на тест: Хотя может быть искушение проверить несколько вещей в одном тесте, лучше сосредоточиться на одной конкретной проверке, чтобы было понятно, что именно пошло не так, если тест не прошел.
3. Читаемость: Тесты часто служат документацией к коду, поэтому их должно быть легко читать и понимать.
4. ARR (Arrange, Act, Assert): Это общепринятый подход к структуре теста. Сначала устанавливаются начальные условия (Arrange), затем выполняется действие, которое вы хотите проверить (Act), и в конце производится проверка ожидаемого результата (Assert).

**Пример (без привязки к конкретному языку):**

Представьте функцию, которая складывает два числа:
```js
function add(a, b):
    return a + b
```
Unit-тест для этой функции может выглядеть так:
```js
test function test_addition():
    // Arrange
    input1 = 2
    input2 = 3
    expected_result = 5
    // Act
    result = add(input1, input2)
    // Assert
    assert result == expected_result
```
Unit-тесты - это ваш первый защитный барьер против багов, инструмент для поддержания качества кода и незаменимый помощник при рефакторинге.

### Unit-тесты в Java

**Первые шаги: JUnit**

Когда говорят о unit-тестировании в Java, первое, что приходит в голову, — это JUnit. Этот фреймворк, созданный Кентом Беком и Эрихом Гамма в конце 90-х, стал де-факто стандартом для написания unit-тестов на Java.

Изначально JUnit был разработан для Java и стал частью большого семейства фреймворков xUnit, каждый из которых предназначен для своего языка программирования. Благодаря простому и интуитивно понятному API, JUnit быстро стал популярным среди разработчиков.

**Эволюция JUnit: От JUnit 3 до JUnit 5**
1. JUnit 3: Первые версии JUnit основывались на именовании методов (все тестовые методы начинались с test). Хотя это было просто, структура тестов могла стать громоздкой.
2. JUnit 4: Введение аннотаций! Это принципиально изменило способ написания тестов. Теперь, чтобы указать тестовый метод, достаточно было добавить @Test перед ним. Это улучшило читаемость кода и добавило гибкости, позволив вводить такие возможности как параметризованные тесты, правила и многое другое.
3. JUnit 5: Современная итерация JUnit, представленная в 2017 году, принесла множество улучшений, в том числе модульную структуру. Это позволило разделить JUnit на три подпроекта: JUnit Platform, JUnit Jupiter и JUnit Vintage. Эта версия добавила много новых функций, таких как динамические тесты, расширенные возможности параметризации и более продвинутые аннотации.

**Также рядом: TestNG, Spock и другие**

Хотя JUnit является самым известным фреймворком для unit-тестирования в Java, существуют и другие инструменты, такие как TestNG и Spock. Эти инструменты предоставляют свои уникальные особенности и подходы к тестированию, предоставляя разработчикам больше возможностей.

В заключении, Java всегда была в авангарде разработки ПО, и в контексте модульного тестирования она дала миру множество инструментов и лучших практик. Будьте уверены, что в ваших руках мощные инструменты для обеспечения качества вашего кода!

### Spring и Unit-тесты

Если вы когда-либо пытались написать unit-тесты для приложения на Spring, то знаете, что иногда это может быть довольно сложно из-за всей магии, которую делает этот фреймворк. Но у меня для вас хорошие новости: Spring обладает замечательными инструментами для упрощения процесса тестирования!

**1. Spring TestContext Framework**

Одной из ключевых фич Spring является его TestContext Framework. Этот фреймворк предоставляет аннотации и утилиты для загрузки Spring ApplicationContext в ваших тестах, что позволяет вам тестировать Spring-компоненты в изолированной среде.

**2. @SpringBootTest**

С помощью аннотации @SpringBootTest вы можете легко загрузить весь контекст вашего приложения или его части. Она автоматически настраивает ваше приложение и предоставляет все необходимое для тестирования.

**3. Mocking с Mockito и @MockBean**

Spring и Mockito идут рука об руку, когда дело доходит до написания unit-тестов. Spring предоставляет аннотацию @MockBean, которая позволяет вам создать mock-версию вашего бина и внедрить ее в контекст Spring. Это особенно полезно, когда вы хотите изолировать конкретный компонент от внешних зависимостей, таких как репозитории или сервисы.

Пример:
```java
@SpringBootTest
public class MyServiceTest {
    @Autowired
    private MyService myService;
    
    @MockBean
    private MyRepository myRepository;
    
    @Test
    public void testMyService() {
        when(myRepository.findSomething()).thenReturn(someData);
        // Некоторые проверки для myService
    }
}
```

**4. @WebMvcTest и @DataJpaTest**

В Spring Boot есть специальные аннотации для тестирования конкретных частей вашего приложения. Например, с @WebMvcTest вы можете тестировать только веб-слои вашего приложения, игнорируя остальное. А с @DataJpaTest можно сфокусироваться исключительно на тестировании JPA репозиториев.

**5. @TestConfiguration**

Определяет дополнительные конфигурационные классы или бины для теста. Эта аннотация помогает определить локальные компоненты, которые будут использоваться только во время тестирования.

Пример:
```java
@TestConfiguration
public class MyTestConfiguration {
    @Bean
    public MyService myService() {
        return new MyMockedService();
    }
}
```

**6. @BeforeAll и @AfterAll**

Использование: Эти аннотации из JUnit 5 используются для определения методов, которые выполняются перед началом всех тестов и после их завершения.

Пример:
```java
@SpringBootTest
public class MyTests {
    @BeforeAll
    public static void init() {
        // Некоторая инициализация
    }

    @AfterAll
    public static void cleanup() {
        // Очистка после тестов
    }
}
```

Spring действительно делает процесс написания unit-тестов проще и более интуитивным. Благодаря встроенным инструментам и интеграции с популярными инструментами, такими как Mockito, вы можете удостовериться, что ваше приложение на Spring надежно и готово к любым вызовам!

### Интеграционные тесты

Интеграционные тесты — это тесты, которые проверяют взаимодействие между различными частями вашего приложения. В отличие от unit-тестов, которые фокусируются на тестировании отдельных модулей или функций, интеграционные тесты обеспечивают проверку того, как эти модули работают вместе.

**Зачем они нужны?**

Представьте себе огромную мозаику из тысячи кусочков. Если каждый кусочек идеально выполнен (это как хорошо написанный модуль или функция), но они плохо сочетаются друг с другом, то итоговая картина будет неудачной. Интеграционные тесты позволяют убедиться, что все кусочки гармонично соединены.

**Какие аспекты они проверяют?**
- Взаимодействие с базами данных: Как ваше приложение обращается к базе? Правильно ли данные записываются и извлекаются?
- Общение с внешними сервисами: Если ваше приложение подключается к сторонним API или другим службам, интеграционные тесты могут проверить, правильно ли это происходит.
- Взаимодействие между модулями: Как одна часть вашего приложения взаимодействует с другой?

**Какие инструменты используются?**

Для интеграционных тестов часто используются специализированные инструменты, которые могут имитировать внешние службы, базы данных или другие части системы. Эти инструменты могут быть частью тестового фреймворка или предоставляться отдельно.

**В чем сложности?**
- Настройка и поддержка: Так как интеграционные тесты взаимодействуют с различными частями системы, они могут быть сложнее в настройке.
- Скорость выполнения: Они обычно выполняются дольше, чем unit-тесты, так как тестируют более сложные взаимодействия.
- Неустойчивость: Из-за зависимости от множества компонентов интеграционные тесты могут быть менее стабильными.

Интеграционные тесты — ключевая часть стратегии тестирования. Они позволяют убедиться, что разные части вашего приложения работают синхронно и гармонично. Хотя они могут требовать дополнительных усилий по сравнению с unit-тестами, они являются неотъемлемой частью создания надежного программного обеспечения.

### История интеграционных тестов

**1. Ранние годы Java**

Когда Java была представлена в 1995 году, основной акцент был сделан на простоту и переносимость кода. Но как и многие новые технологии того времени, она не имела широкого арсенала инструментов для тестирования. Разработчики опирались на ручное тестирование и простые скрипты для проверки своего кода.

**2. Появление JUnit**

В конце 1990-х годов JUnit появился как революционный инструмент для unit-тестирования в Java. Хотя первоначально он был ориентирован на тестирование отдельных модулей, с течением времени он стал основой для разработки интеграционных тестов, благодаря своей гибкости и расширяемости.

**3. Рост популярности Maven и Ant**

В начале 2000-х годов инструменты сборки, такие как Maven и Ant, стали популярными в Java-сообществе. Они предоставили структурированный способ управления жизненным циклом проекта, включая фазы тестирования. С их помощью интеграционные тесты стали более автоматизированными и частью процесса сборки.

**4. Появление инструментов для интеграционного тестирования**

После того как основа была заложена с JUnit, Maven и Ant, стали появляться специализированные инструменты для интеграционного тестирования в Java. Инструменты, такие как Arquillian, позволяли разработчикам тестировать взаимодействие кода Java с различными серверами приложений, базами данных и другими внешними компонентами.

**5. Современные тенденции**

На протяжении последних лет Java продолжает быть в авангарде интеграционного тестирования. Широкий спектр инструментов, фреймворков и практик доступен для разработчиков, чтобы обеспечить качество и надежность своих Java-приложений.

Интеграционное тестирование в Java прошло долгий путь с момента своего зарождения. С развитием языка и технологий разработчики получили множество мощных инструментов и практик для обеспечения качества своих приложений. Вероятно, развитие в этой области продолжится, и будущее обещает быть еще более интересным!

### Интеграционные тесты на Spring

Spring прекрасно работает с JUnit, что делает написание и запуск интеграционных тестов проще. Вам не придется изобретать колесо, всё уже здесь, готово к использованию! Для этого у него есть следующие компоненты:

**1. Spring TestContext Framework**

Spring предоставляет TestContext Framework, который обеспечивает функциональности для загрузки контекста Spring и кэширования его между тестовыми выполнениями для повышения производительности. Это очень удобно, когда у вас есть тяжелые интеграционные тесты, работающие с реальной БД или другими внешними ресурсами.

**2. @SpringBootTest**

Аннотация @SpringBootTest автоматически конфигурирует ваше приложение, поднимает встроенный сервер и готовит всё для интеграционного тестирования. Она создает реальный контекст вашего приложения, что позволяет тестировать его так, как если бы оно работало в продакшене.

**3. Встроенная поддержка баз данных**

Spring позволяет легко настраивать встраиваемые базы данных, такие как H2, HSQL или Derby, для тестирования. Это удобно, потому что не требует отдельной конфигурации или настройки реальной базы данных.

**4. MockMvc для веб-тестирования**

Если вы разрабатываете веб-приложение, MockMvc станет вашим лучшим другом. Он позволяет быстро и легко создавать запросы к вашему приложению и проверять ответы, не запуская реальный сервер.

**5. Spring Boot Test Slices**

Spring Boot предлагает возможность “срезов тестов” (Test Slices), которые позволяют тестировать только определенные части вашего приложения, автоматически настраивая нужные компоненты. Например, @DataJpaTest настроит только слой JPA вашего приложения для тестирования.

Интеграционное тестирование в Spring — это настоящее удовольствие благодаря огромному арсеналу инструментов и возможностей, которые он предоставляет. И лучшая часть? Все эти инструменты разработаны так, чтобы упростить вашу жизнь и сделать процесс тестирования как можно более эффективным.

### Нагрузочное тестирование

Нагрузочное тестирование (НТ) — это процесс проверки системы или компонента на его способность управлять заданной нагрузкой, обычно с учетом ожидаемого числа пользователей и операций в определенное время.

**Зачем нам это?**
- Производительность: НТ помогает удостовериться, что ваше приложение будет работать быстро, даже при большой нагрузке.
- Стабильность: Мы хотим узнать, не упадет ли наше приложение или не будет ли “тормозить”, когда много пользователей пытаются им пользоваться одновременно.
- Масштабируемость: Узнайте, насколько легко добавлять ресурсы (например, память, процессоры или серверы) для обработки дополнительной нагрузки.

**Как провести нагрузочное тестирование?**
1. Определите ожидаемую нагрузку: Начните с определения, сколько пользователей вы ожидаете на своем сайте или приложении в пиковые часы.
2. Создайте тестовые сценарии: Определите, какие операции пользователи будут чаще всего выполнять. Это может быть, например, поиск, добавление товара в корзину или просмотр видео.
3. Подготовьте тестовое окружение: Убедитесь, что ваша тестовая среда максимально приближена к реальной. Это может включать в себя настройку серверов, баз данных и сети.
4. Выполните тесты: Используйте специализированные инструменты для нагрузочного тестирования, чтобы имитировать действия многих пользователей одновременно.
5. Анализируйте результаты: После тестирования изучите данные, чтобы выявить узкие места или проблемы производительности, и определить, соответствует ли система вашим требованиям.

**Отличия от других видов тестирования**

НТ отличается от других типов тестирования, таких как функциональное или интеграционное, тем, что его основной целью является определение производительности, а не нахождение ошибок или багов.

Нагрузочное тестирование — неотъемлемая часть процесса разработки, которая помогает гарантировать, что ваше приложение будет работать гладко и без проблем, даже при большом количестве пользователей. Это вложение времени и ресурсов, которое, безусловно, окупится в будущем, когда ваш продукт стоит перед реальной аудиторией!