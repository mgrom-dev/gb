## Урок 9. Spring Cloud. Микросервисная архитектура

### Введение

Сегодня мы поговорим про Spring Cloud и микросервисы. Это следующий этапе в эволюции после AOP в разработке – переход от монолитных приложений к микросервисам.

Возможно, вы слышали слово “монолит”, которое описывает приложение, состоящее из одного гигантского блока кода. По сути, все компоненты, функционал и слои в таком приложении находятся в одном месте. Именно так работали многие проекты ещё несколько лет назад. Но прогресс не стоит на месте, и появилась потребность в более гибких, масштабируемых и удобных в обслуживании системах. И тут на помощь приходят микросервисы!

Давайте представим, что вы строите город. Если бы город был монолитом, то это как если бы все горожане жили бы в одном огромном доме. Один кран сломался? Весь дом без воды. Хотите добавить несколько новых комнат? Весь дом нужно перестраивать!

А теперь представьте, что вместо одного большого дома у нас есть множество маленьких домиков — каждый со своей системой отопления, водоснабжения и т. д. Это и есть микросервисы.

Spring Cloud предоставляет нам инструменты для создания таких систем на основе микросервисов, но давайте не спешить и узнаем о нем побольше в следующих разделах.

Теперь к преимуществам:
- Масштабируемость: Вернемся к нашим домикам. Если в одном районе стало много жителей, можно легко построить еще один такой же домик рядом. В мире микросервисов, если одна часть системы испытывает нагрузку, мы можем просто добавить еще один такой же микросервис, чтобы поделить эту нагрузку.
- Устойчивость: Вспомните про кран. Если в одном домике сломается кран, это не затронет другие домики. Так же и с микросервисами: если один сервис “падает”, другие продолжают работать.
- Независимость компонентов: Каждый домик может быть построен из разных материалов, в разном стиле и даже иметь свою собственную систему безопасности. Так и с микросервисами: каждый может быть написан на разных языках программирования, иметь свою базу данных и обновляться независимо от других.

По сути, микросервисы предлагают нам гибкость. Вместо того чтобы зависеть от одного “огромного дома”, мы управляем множеством маленьких, что делает жизнь намного проще и удобнее.

### Термины, используемые в лекции

**Микросервис** — Это подход к разработке программного обеспечения, при котором приложение состоит из мелких, независимых компонентов, работающих вместе.

**Eureka Server** — Сервис от Netflix, интегрированный в Spring Cloud, который предоставляет сервис обнаружения, где микросервисы могут регистрироваться и находить друг друга.

**Zuul Proxy** — Используется в Spring Cloud в качестве маршрутизатора и прокси-сервера между клиентом и микросервисами.

**Spring Cloud Config Server** — Централизованный сервер для управления конфигурациями микросервисов через все окружения.

**Load Balancing** — Распределение входящего трафика между множеством серверов или микросервисов.

**Feign Client** — Декларативный web-клиент от Netflix, интегрированный в Spring Cloud, который упрощает написание кода для взаимодействия с другими микросервисами.

**Hystrix** — Библиотека от Netflix, интегрированная в Spring Cloud, предоставляющая латентное и отказоустойчивое выполнение.

**Circuit Breaker Pattern** — Подход, который позволяет системе продолжать работу, даже когда часть необходимых сервисов временно недоступна.

**Spring Cloud Bus** — Механизм, который соединяет различные узлы микросервисного комплекса с легкостью и доступностью облачного средства.

**Service Mesh** — Подход к управлению и контролю трафика между микросервисами.

**API Gateway** — Сервер, который является точкой входа в микросервисную архитектуру и маршрутизирует запросы к соответствующим службам.

**Service Registry & Discovery** — Механизм для автоматической регистрации и
обнаружения микросервисов в среде.

**Distributed Tracing** — Подход к мониторингу запросов в микросервисной архитектуре, позволяющий отслеживать выполнение запроса через все микросервисы.

**Spring Cloud Stream** — Фреймворк для создания приложений для обработки потоковых данных с использованием Spring Boot.

**Spring Cloud Data Flow** — Инструмент для оркестровки приложений потоковых данных на основе Spring Cloud Stream

### Популярность микросервисов

Представьте, что у вас есть пазл из тысячи кусочков. Вы точно знаете, что каждый кусочек имеет своё место, и в случае необходимости вы можете заменить один кусочек, не разбирая всю картину. Таким образом, микросервисы - это как кусочки этого пазла, позволяющие создавать гибкие и адаптивные системы. Но давайте поговорим, почему именно микросервисы стали такими популярными.
1. Быстрый тайм ту маркет: Крупные компании и стартапы хотят запустить новые продукты и функции как можно быстрее. С микросервисами, они могут разрабатывать, тестировать и выпускать отдельные части системы без необходимости ждать остальную часть. Это как если бы вы улучшали одну комнату в доме, не перестраивая весь дом.
2. Талантливые команды: В мире разработки всё больше талантливых специалистов с разными навыками. Микросервисы позволяют командам использовать разные технологии и языки программирования для разных сервисов. Это как если бы на стройке каждая бригада строила свою часть дома, используя свои предпочтения в материалах и инструментах.
3. Масштабирование при минимальных затратах: Крупные компании сталкиваются с проблемой обработки большого количества данных и запросов. Микросервисы позволяют масштабировать только те части системы, которые это действительно нужно, сэкономив ресурсы и деньги.
4. Разделение ответственности: В крупных организациях, где много команд, микросервисы обеспечивают четкое разделение ответственности. Каждая команда может заниматься своим микросервисом, не беспокоясь о том, что ее изменения повлияют на работу других команд.
5. Инновации и эксперименты: Стартапы, известные своими инновациями, любят экспериментировать. С микросервисами они могут быстро создавать новые функции, экспериментировать с ними, и если что-то идет не так, просто отключить или заменить этот микросервис без риска для всей системы.

В итоге, микросервисы предоставляют гибкость, масштабируемость и возможность быстрого внедрения изменений, что делает их идеальным выбором для современных крупных компаний и динамичных стартапов.

### Отказоустойчивость и самовосстановление

Вспомните ощущение, когда вы играете в домино, и одна фишка случайно падает, опрокидывая остальные за собой. В мире микросервисов, если один сервис “падает”, это может вызвать цепную реакцию сбоев по всей системе. Однако, в отличие от домино, нам не нужно, чтобы наши сервисы ломали друг друга!

Итак, почему в микросервисной архитектуре так важна отказоустойчивость и быстрое восстановление?
1. Множество сервисов: Когда у вас много маленьких сервисов, вероятность того, что один из них в какой-то момент “упадет”, гораздо выше, чем если бы у вас было одно монолитное приложение. Поэтому нам нужно быть готовыми к таким ситуациям.
2. Независимость: Хотя каждый микросервис независим, они часто взаимодействуют друг с другом. Если один сервис не работает, это может затруднить работу других. Поэтому быстрое восстановление после сбоев критично для общей производительности системы.
3. Пользовательский опыт: Никто не любит, когда сайт или приложение не работает. Быстрое восстановление сервиса обеспечивает лучший пользовательский опыт и удерживает клиентов.

И тут на помощь приходит Spring Cloud! Этот инструмент предоставляет ряд решений, специально разработанных для микросервисной архитектуры, чтобы сделать наши приложения более устойчивыми к сбоям. Он предлагает такие функции, как автоматическое масштабирование, балансировка нагрузки, обнаружение сервисов и даже обработку сбоев. Таким образом, даже если один из наших микросервисов “падает”, Spring Cloud поможет быстро восстановить его или перераспределить трафик, чтобы минимизировать воздействие на пользователей.

В общем, живя в мире микросервисов, мы должны быть всегда готовы к неожиданным проблемам. Но с правильными инструментами, такими как Spring Cloud, мы можем быть уверены в том, что наша система будет работать плавно и эффективно, даже в самых сложных условиях.

### Spring Cloud

Spring Cloud — это не просто единственный инструмент или библиотека. Это целый набор инструментов и решений, предоставляемых командой Spring, чтобы упростить разработку, управление и масштабирование микросервисных приложений.

Так что же делает Spring Cloud таким особенным?
1. Упрощение разработки: Когда речь идет о создании микросервисов, есть много повторяющихся задач и проблем, с которыми сталкиваются разработчики. Spring Cloud предлагает готовые решения для большинства из них, позволяя вам сконцентрироваться на бизнес-логике, а не на “изобретении велосипеда”.
2. Бесшовное взаимодействие: В мире микросервисов сервисы постоянно общаются друг с другом. Spring Cloud предоставляет механизмы для упрощения этого взаимодействия, будь то обнаружение сервисов, конфигурация или обработка сбоев.
3. Отказоустойчивость: Как мы уже говорили ранее, быстрое восстановление после сбоев критически важно в микросервисной архитектуре. Spring Cloud включает в себя решения для мониторинга, обнаружения проблем и автоматического восстановления сервисов.

В общем, Spring Cloud — это как мост, соединяющий все микросервисы в единую, управляемую и надежную систему. С его помощью разработчики могут спать спокойно, зная, что многие сложные аспекты управления микросервисами уже решены за них.

### Компоненты Spring Cloud

Spring Cloud, как вы уже, наверное, догадались, не просто один инструмент. Это целый “набор инструментов” для разработчиков. Представьте себе конструктор LEGO: у вас есть множество разных деталей, каждая из которых имеет свое назначение. Но когда вы собираете их вместе, вы можете создать что-то действительно крутое!

Давайте рассмотрим некоторые ключевые компоненты Spring Cloud:
1. Spring Cloud Config: Этот компонент управляет внешними настройками для приложений во всех окружениях. Представьте, что у вас есть универсальный пульт управления для всех настроек ваших микросервисов!
2. Spring Cloud Netflix: На самом деле это набор подпроектов, вдохновленных Netflix OSS. К нему относятся:
   - Eureka для обнаружения сервисов.
   - Hystrix для контроля над временем ожидания между микросервисами и обработки сбоев.
   - Zuul для маршрутизации и фильтрации на уровне API.
3. Spring Cloud Gateway: Это более современный маршрутизатор на основе Spring, который можно использовать в качестве альтернативы Zuul.
4. Spring Cloud Bus: Этот компонент использует легковесные сообщения (часто с помощью RabbitMQ или Kafka) для обмена информацией между различными частями системы.

Так как же все эти компоненты могут работать вместе?

Представьте сценарий, где у вас есть несколько микросервисов. Вместо того, чтобы каждый из них имел свои отдельные настройки, вы используете Spring Cloud Config для централизованного управления конфигурацией. Теперь, когда один из микросервисов хочет общаться с другим, он использует Eureka для обнаружения этого сервиса. Затем, чтобы гарантировать надежное взаимодействие, он применяет Hystrix для обработки сбоев и контроля времени ожидания. Весь входящий трафик может проходить через Zuul или Spring Cloud Gateway, которые решают, к какому микросервису направить запрос. И в случае любых изменений в системе, Spring Cloud Bus может распространять эти изменения между всеми компонентами.

Таким образом, все эти “кусочки” Spring Cloud соединяются вместе, создавая надежную, масштабируемую и устойчивую микросервисную архитектуру.

### Eureka

Давайте начнем с вопроса: когда вы хотите позвонить своему другу, что вы делаете? Вероятно, вы открываете свои контакты и ищете его имя, чтобы узнать номер телефона, правильно? В мире микросервисов есть что-то похожее, и это называется “обнаружение сервисов”. Eureka от Spring Cloud Netflix — это одно из самых популярных решений для этой задачи.

**Что такое Eureka?**

Eureka — это система обнаружения сервисов, которую можно представить как “телефонную книгу” для ваших микросервисов. Когда микросервис запускается, он регистрируется в Eureka, сообщая ей: “Привет, я здесь, и вот мой адрес!”. Теперь, когда другой микросервис хочет общаться с ним, он просто спрашивает Eureka: “Где мой друг, микросервис X?” Eureka, в свою очередь, предоставляет адрес нужного микросервиса, и взаимодействие может начаться.

**Зачем это нужно?**
1. Динамичность: В современных облачных средах микросервисы могут постоянно перезапускаться, менять свое местоположение и масштабироваться. Без системы обнаружения сервисов было бы сложно отслеживать их все.
2. Балансировка нагрузки: Eureka не только помогает обнаруживать сервисы, но и может управлять трафиком, распределяя его между различными экземплярами одного и того же микросервиса.
3. Отказоустойчивость: Если один из микросервисов становится недоступным, Eureka знает об этом и перенаправляет трафик на другие, работающие экземпляры этого сервиса.

**Как это работает?**

Eureka состоит из двух основных компонентов:
1. Eureka Server: Это центральное место, где хранится информация обо всех зарегистрированных микросервисах. Можно представить его как “центральную телефонную книгу”.
2. Eureka Client: Это библиотека, которую включают в каждый микросервис. Она позволяет микросервису регистрироваться в Eureka Server и запрашивать информацию о других сервисах.

В итоге Eureka создает удобную, централизованную и автоматизированную систему для обнаружения и управления микросервисами в вашей архитектуре.

Давайте рассмотрим, как легко начать работать с Eureka на практике

**1. Настройка Eureka Server**

Для начала нам нужно настроить сервер Eureka

1.1. Добавьте зависимости в ваш pom.xml (если вы используете Maven):
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
</dependency>
```
1.2. В вашем главном классе приложения добавьте аннотацию @EnableEurekaServer:
```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```
1.3. Настройте application.properties или application.yml:
```yaml
server.port=8761
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
```
Теперь, запустив приложение, у вас будет работающий сервер Eureka на порту 8761.

**2. Регистрация микросервиса как Eureka Client**

Чтобы ваш микросервис мог регистрироваться на сервере Eureka, выполните следующие шаги:

2.1. Добавьте зависимость в pom.xml
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```
2.2. В вашем главном классе приложения добавьте аннотацию @EnableEurekaClient:
```java
@SpringBootApplication
@EnableEurekaClient
public class MyMicroserviceApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyMicroserviceApplication.class, args);
    }
}
```
2.3. В конфигурационном файле укажите адрес сервера Eureka:
```yaml
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
```
Теперь, каждый раз когда вы запускаете свой микросервис, он автоматически регистрируется на сервере Eureka.

После этих действий вы можете посетить веб-интерфейс Eureka Server на http://localhost:8761 и увидеть свой микросервис в списке.

### Zuul