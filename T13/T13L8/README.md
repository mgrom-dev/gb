## Урок 8. Spring AOP, управление транзакциями

### Термины, используемые в лекции

**Aspect** – модуль, который определяет Advices, срезы и привязки. Это кросс-функциональные заботы, такие как логирование, аудит, безопасность и т. д.

**Join Point** – точка в программе, такая как выполнение метода, где можно применить Advices (advice). В Spring AOP, join points представляют собой выполнение методов.

**Advice** – действие, предпринимаемое аспектом в определенной точке соединения. Существуют разные типы Advices, такие как before, after, after-returning, after-throwing, и around.

**Pointcut** – выражение, которое выбирает определенные join points. Advices применяются к join points, выбранным через pointcuts.

**Target** – объект, к которому применяется Advices.

**Proxy** – объект, созданный после применения Advicesа к целевому объекту.

**Weaving** – процесс комбинирования аспектов с другим типом приложения для создания прокси-объекта. Это может быть выполнено во время компиляции (CTW), загрузки класса (LTW) или во время выполнения.

**Introduction (Inter-type declaration)** – добавление новых методов или свойств в существующие классы.

**Транзакция** – последовательность действий, которые либо полностью выполняются, либо полностью отменяются.

**ACID** – принципы транзакций — Атомарность, Согласованность, Изоляция и Долговечность (Atomicity, Consistency, Isolation, Durability).

**Propagation** – определяет, как транзакции относятся к друг другу. Например, REQUIRED, REQUIRES_NEW, SUPPORTS и т. д.

**Isolation** – уровень изоляции транзакции определяет, как данные, доступные одной транзакции, становятся видимыми для других.

**@Transactional** – аннотация Spring для объявления транзакционного метода.

**Transaction Manager** – компонент, который управляет транзакциями. Например, DataSourceTransactionManager для JDBC.

**Rollback** – отмена изменений, выполненных в рамках транзакции.

### Spring AOP

Первое, что нужно сказать: AOP это сокращение от Aspect-Oriented Programming.

Представьте, что у вас есть дом. В этом доме есть разные комнаты: кухня, спальня, гостиная и так далее. Теперь представьте, что вы решаете установить в доме систему безопасности. В каждой комнате вы ставите датчик движения. Но ведь датчик движения — это не основная часть комнаты, верно? Он просто добавляется для выполнения какой-то дополнительной функции.

В этом примере каждая комната — это какой-то отдельный модуль вашего приложения. А система безопасности, которую вы решили добавить — это пример функции, которую вы хотите “вплести” в разные части вашего приложения, не меняя их основного кода. Именно это и позволяет сделать AOP!

Теперь, давайте поговорим о разнице между AOP и ООП. ООП, или объектно-ориентированное программирование, — это способ организации кода, когда все строится вокруг объектов и их взаимодействий. Как будто у вас есть игрушечные фигурки (объекты), каждая из которых может что-то делать (методы) и иметь свои характеристики (атрибуты).

Тогда как AOP — это скорее “волшебный плащ”, который можно накинуть на несколько из этих фигурок одновременно, чтобы добавить им какую-то дополнительную функцию, не меняя их самих. Это не новый способ организации кода, а дополнение к существующим методикам, позволяющее легко внедрять функции в разные части приложения.

**Взаимосвязь с предыдущими темами**

Прежде чем говорить о важности Spring AOP, давайте разберемся, как этот компонент связан с теми, которые мы уже прошли.

Помните наш разговор о Spring MVC? Так вот, когда вы создаете контроллеры и обрабатываете запросы, иногда вы хотите добавить дополнительное поведение к этим контроллерам. Например, залогировать запросы или измерить время их выполнения. Вместо того чтобы добавлять эти дополнительные функции в каждый контроллер, вы можете использовать Spring AOP, чтобы автоматически применять это поведение ко многим частям вашего приложения.

А что насчет Spring Security? Часто нам нужно управлять доступом к определенным методам или функциям приложения. С помощью Spring AOP, вы можете легко добавить аспекты безопасности на нужные вам уровни приложения.

Теперь давайте представим, что у вас есть сложный проект, где вы используете Spring Data для работы с базой данных. И вам нужно залогировать все запросы к базе или измерить, сколько времени занимает каждый запрос. Опять-таки, вместо того чтобы добавлять логику в каждый репозиторий или сервис, вы можете использовать Spring AOP для этой цели.

Таким образом, Spring AOP как бы вяжет воедино все наши предыдущие темы, добавляя дополнительную мощь и гибкость.

**Важность в коммерческой разработке**

Теперь, когда мы знаем, как Spring AOP связан с нашими предыдущими уроками, давайте поговорим о том, как это используется на практике, особенно в крупных компаниях.

В первую очередь, Spring AOP помогает разработчикам писать более чистый и модульный код. Вы можете сосредоточиться на основной логике вашего приложения, не беспокоясь о дополнительных функциях, таких как логирование или безопасность. Эти “перекрестные” задачи (cross-cutting concerns) легко управляются с помощью аспектов в AOP.

В крупных компаниях, где десятки, если не сотни разработчиков работают над сложными и масштабными проектами, управление такими “перекрестными” задачами может стать настоящим вызовом. И здесь Spring AOP может стать настоящим спасением.

Например, представьте, что в вашей компании решили изменить формат логирования. Если вы не используете AOP, вам, возможно, придется искать и менять код логирования в сотнях мест. Но с AOP вы просто обновляете один аспект, и изменения автоматически применяются во всем проекте.

В заключение, Spring AOP - это мощный инструмент, который помогает управлять повторяющимися и “перекрестными” задачами в вашем приложении. В крупных коммерческих проектах это может существенно ускорить разработку, упростить поддержку кода и улучшить качество продукта.

### Аспекты в Spring AOP

**Что такое аспект?**

Вернемся к нашему примеру с домом, где мы установили датчики движения. Если бы этот дом был нашим приложением, а датчики - определенной функциональностью, которую мы хотим добавить, то сама система безопасности (вся схема с датчиками, сигнализацией и так далее) была бы аспектом.

Аспект в Spring AOP — это модуль, который определяет “перекрестные” или “сквозные” задачи, такие как логирование, безопасность или транзакции. Эти задачи обычно затрагивают многие части приложения и не связаны напрямую с бизнес-логикой.

**Как аспекты работают?**

Аспекты работают таким образом, что они “внедряются” или “вплетаются” в ваш код в определенные места, которые вы указываете. Это похоже на то, как вы можете настроить датчики движения в разных комнатах вашего дома. Когда происходит какое-то событие (например, движение в комнате), датчик реагирует на него. Аналогично, когда определенная часть вашего кода выполняется, аспект может “реагировать” на это, выполняя нужные действия.

**Зачем это нужно?**

Представьте, что у вас есть огромный пазл, где каждая деталька — это часть вашего приложения. Аспекты позволяют нам не изменять каждую детальку отдельно, а “налепить” на несколько из них стикер с дополнительной информацией или функциональностью. Это экономит время, уменьшает ошибки и делает код более чистым и организованным.

В больших проектах аспекты становятся незаменимыми, потому что представьте, что при изменении требований вам нужно менять одну и ту же функцию в десятках или даже сотнях мест. С аспектами вы просто меняете функциональность один раз, и она автоматически применяется везде, где нужно.

Аспекты в Spring AOP — это способ организовать “сквозную” функциональность в вашем приложении без необходимости менять основной код. Это как магические стикеры, которые вы можете приклеить к любой части вашего кода, чтобы добавить дополнительное поведение или функциональность.

### Примеры использования аспектов в Spring AOP

Давайте погрузимся в конкретные примеры, чтобы понять, как это работает на практике!

**1. Логирование методов**

Допустим, вы хотите логировать каждый вызов определенного метода. Вместо того чтобы добавлять логирующий код в каждый метод, вы можете создать аспект для этого.
```java
@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodCall(JoinPoint joinPoint) {
        System.out.println("Метод " + joinPoint.getSignature().getName() + "был вызван");
    }
}
```
В этом примере @Before говорит о том, что аспект должен выполняться перед вызовом метода, а выражение в execution() указывает на то, какие именно методы нужно “перехватить”. В данном случае перехватываются все методы из всех классов в пакете com.example.service.

**2. Измерение времени выполнения**

