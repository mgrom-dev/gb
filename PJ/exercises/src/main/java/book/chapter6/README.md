## Глава 6. Управление доступом (стр. 187)
### Задания:
1. (1) Определите класс в пакете. Создайте экземпляр класса за пределами пакета. (стр. 192)
2. (2) Преобразуйте фрагменты из этого раздела в программу. Убедитесь в том, что конфликты имен действительно возникают.
3. (2) Создайте два пакета debug и debugoff, содержащие одинаковые классы с методом debug(). Первая версия выводит на консоль свой аргумент типа String, вторая не делает ничего. Используйте директиву static import для импортирования класса в тестовую программу и продемонстрируйте эффект условной компиляции. (стр. 195)
4. (2) Покажите, что методы со спецификатором protected обладают доступом в пределах пакета, но не являются открытыми.
5. (2) Создайте класс с полями и методами, обладающими разными уровнями доступа: public, private, protected, доступом в пределах пакета. Создайте объект этого класса и посмотрите, какие сообщения выдает компилятор при попытке обращения к разным членам класса. Учтите, что классы, находящиеся в одном каталоге, входят в «пакет по умолчанию».
6. (1) Создайте класс с защищенными данными. Создайте в том же файле второй класс с методом, работающим с защищенными данными из первого класса. (стр. 200)
7. (1) Создайте библиотеку в соответствии с фрагментами кода, содержащими описания access и Widget. Создайте объект Widget в классе, не входящем в пакет access. (стр. 203)
8. (4) По образцу примера Lunch.java создайте класс с именем ConnectionManager, который управляет фиксированным массивом объектов Connection. Программист- клиент не должен напрямую создавать объекты Connection, а может получать их только с помощью статического метода в классе ConnectionManager. Когда запас объектов у класса ConnectionManager будет исчерпан, он должен вернуть ссылку null. Протестируйте классы в методе main().
9. (2) Поместите следующий файл в каталог access/local (предположительно заданный в переменной CLASSPATH) (стр. 204)