## Урок 3. SQL – выборка данных, сортировка, агрегатные функции

### Получение данных, блок GROUP BY

Группировка необходима тогда, когда данные нужно обработать и перегруппировать. Данные хранятся в каком-то относительно сыром виде. Например, если мы возьмем чеки, то каждый кортеж данных будет представлять из себя записи какую позицию человек купил, идентификатор чека, поскольку обычно в одном чеке у клиента несколько товаров, айдишник клиента, если он представил карту клиента и время закрытия чека. Естественно, к таким данным у бизнеса будут вопросы по агрегатам. Например, сколько было продано каждого товара за день/месяц (проследить эволюцию продаж), как различаются сумма чеков у разных клиентов. Как раз для этого и необходима группировка.

Если мы будем хранить уже сгруппированные данные, то не сможем их обратно разгруппировать и получить другие метрики. С другой стороны хранение сырых данных позволяет отслеживать изменения. Как только какой-то товар купили, мы это сразу видим в таблице без применения каких либо обработок. Поэтому под каждую задачу необходимо писать отдельный запрос на группировку.

А что тогда агрегатные функции?

Агрегатные функции — это те функции, которые позволяют нам получить необходимые метрики или обобщить данные. Так например. Если мы хотим посмотреть дневные траты по каждому клиенту, то нам необходимо взять сумму трат по каждой позиции в чеке для каждого клиента за день. Если мы хотим знать сколько было посетителей в магазине за день, то нам необходимо посчитать количество уникальных айдишников клиентов за день или количество чеков за день. Обе метрики могут быть полезны, так как не все клиенты применяют карты лояльности.

Давайте посмотрим, как работает группировка. У нас есть таблица с заказами и к нам пришел заказчик и говорит, что ему необходимо знать, сколько заказов делалось каждый день. Для этого нам понадобится группировка по дню. Мы можем написать вот такой запрос.
```sql
SELECT
OrderDate
FROM Orders
GROUP by OrderDate
```
Как мы видели на первой лекции, такой запрос эквивалентен использованию оператора DISTINCT. Но нам кроме самих уникальных дат формирования заказов, необходимо получить количество заказов в этот день. Для этого мы можем добавить агрегатную функцию COUNT. Параметром этой функции можно взять любое поле, в котором нет пропусков (NULL), потому что пропуски не считаются. Поэтому здесь возможно два способа. Если вам необходимо подсчитать количество строк с записями заказов, то можно использовать COUNT(*). Тогда хотя бы одно из полей таблицы будет не пустым и вы получите количество записей за каждый день. С другой стороны, можно указать конкретное поле, которое нас интересует. И мы получим количество записей без пропусков.
```sql
SELECT
OrderDate
,COUNT(*)
FROM Orders
GROUP by OrderDate
```
Таким образом мы получили самую простую группировку наших данных. Давайте разберемся, в написанном запросе. В блоке GROUP BY мы будем указывать поля или метрики из полей, по которым происходит группировка. Эти же поля или метрики принято указывать и в блоке SELECT. Дальше в блоке SELECT указывают агрегатные функции для расчета требуемых метрик.

Давайте посмотрим, как использовать метрики полей для группировки. Например бизнес хочет знать по месяцам количества заказов, то есть сколько было сделано заказов в августе, сентябре. Для получения данной информации необходимо группироваться по номеру месяца. Тогда запрос будет выглядеть следующим образом.
```sql
SELECT
YEAR(OrderDate) AS year
,MONTH(OrderDate) as month
,COUNT(*) As cnt
FROM Orders
GROUP by YEAR(OrderDate)
,MONTH(OrderDate)
ORDER BY YEAR(OrderDate)
,MONTH(OrderDate)
```
Как видно из запроса, для выполнения данной задачи мы использовали двойную группировку по году и месяцу. Это связано с тем, что скорее всего в боевой базе у вас будет многолетняя история и если группироваться только по месяцу, то мы получим сумму заказов за разные годы.

Другая особенность запроса заключается в том, что во всех трех блоках (SELECT, GROUP BY, ORDER BY) мы использовали функции от наших полей. Но если мы вспомним порядок выполнения запроса, то он будет следующий FROM -> GROUP BY -> SELECT -> ORDER BY. То есть в момент группировки мы еще не знаем имен для наших новых колонок, которые рассчитываем в блоке SELECT. Поэтому нам приходится в блоке группировки снова рассчитывать эти показатели (месяц и год). Однако в момент выполнения сортировки, колонки уже определены и мы можем в принципе использовать их имена. Например вместо сортировки по году и месяцу можно поставить сортировку по количеству заказов, чтобы узнать какие месяцы были удачными по продажам, а какие не очень.
```sql
SELECT
YEAR(OrderDate) AS year
,MONTH(OrderDate) as month
,COUNT(*) As cnt
FROM Orders
GROUP by YEAR(OrderDate)
,MONTH(OrderDate)
ORDER BY cnt
```
В результате мы сразу видим аналитику в наших данных. Больше всего заказов было сделано в декабре и январе месяце, что видимо связано с формированием новогодних подарков.

### Получение данных, блок HAVING

Отлично, в прошлом запросе мы посмотрели количество заказов, которые были совершены за каждый месяц. Допустим теперь заказчик хочет знать месяца в которых было сделано от 20 до 25 заказов. Можно было бы подумать, что для этого нам понадобиться блок WHERE. Однако, как мы знаем, этот блок выполняется сразу после блока FROM. То есть в момент выполнения блока WHERE мы еще не рассчитали статистику и не можем сделать данную фильтрацию. Как раз для таких случаев, когда применяется группировка, для фильтрации полученных агрегатов служит блок HAVING. В данном блоке мы уже можем указывать фильтры к полученным агрегатам, но при этом не можем фильтровать начальные данные. Давайте реализуем запрос от бизнеса.
```sql
SELECT
YEAR(OrderDate) AS year
,MONTH(OrderDate) as month
,COUNT(*) As cnt
FROM Orders
GROUP by YEAR(OrderDate)
,MONTH(OrderDate)
HAVING COUNT(*) BETWEEN 20 and 25
ORDER BY cnt
```
Как видно, мы справились с задачей, смогли выбрать нужные месяца по продажам. Как видно, из-за последовательности выполнения запросов в блоке HAVING мы также указываем некоторую агрегационную функцию. При этом естественно, что агрегационные функции в блоках HAVING и SELECT могут различаться. То есть фильтровать и выводить можно разные метрики.

### Агрегатные функции

Теперь давайте посмотрим самые распространенные агрегационные функции.
|Функция| Описание|
|-|-|
|SUM(поле_таблицы) |Возвращает сумму значений|
|AVG(поле_таблицы) |Возвращает среднее значение|
|COUNT(поле_таблицы) |Возвращает количество записей|
|MIN(поле_таблицы) |Возвращает минимальное значение|
|MAX(поле_таблицы) |Возвращает максимальное значение|
|SDTEV(поле_таблицы) |Возвращает дисперсию значений|

Давайте попробуем посмотреть аналитику по запрашиваемой величине кредита клиентами credit_amount в таблице Clusters в разрезе пола клиента и его статуса в банке (поле is_client)
```sql
SELECT sex
,is_client
,MIN(credit_amount) AS min
,MAX(credit_amount) as max
,AVG(credit_amount) as mean
,STDEV(credit_amount) as std
,COUNT(credit_amount) as cnt
FROM Clusters
GROUP BY sex, is_client
```
Из данного запроса видно, что в целом мужчины запрашивают более высокий кредит, чем женщины. При этом клиенты банка также просят больше денег, чем не клиенты.

Подобную аналитику можно сделать также по другим различным показателям. Например очень интересную статистику можно получить при группировке по полу и образованию наших клиентов.
```sql
SELECT sex
,education
,MIN(credit_amount) AS min
,MAX(credit_amount) as max
,AVG(credit_amount) as mean
,STDEV(credit_amount) as std
,COUNT(credit_amount) as cnt
FROM Clusters
GROUP BY sex, education
ORDER BY sex, mean
```
Как видим из результата выполнения запроса, мы получили все уникальные комбинации пола и образования наших клиентов. Поскольку таких комбинаций уже достаточно много, то нам понадобилась сортировка в этом запросе. Для удобства я отсортировал по полу и средней величине кредита. В целом можно увидеть, что чем выше уровень образования, тем больше кредит просит клиент. Из дополнительных наблюдений в колонке с дисперсией присутствует NULL. Это вызвано тем, что мы не можем рассчитать дисперсию по одному наблюдению и SQL нам не может вернут значение.

В целом это основные агрегатные функции, которые используются при группировке. Но надо понимать, что этот список на самом деле гораздо больше. И если вам при работе потребуются другие метрики, то их можно найти в интернете.

### Подзапросы

На прошлой лекции мы говорили, что для улучшения читаемости скрипта можно определять отдельные переменные. Также говорили, что в качестве переменных могут быть и таблицы. Сегодня мы дополнительно разберем подзапросы. Подзапросы являются одним из самых мощных инструментов в SQL, который можно использовать в любых видах запросов. Подзапрос — это запрос, использующийся в другом SQL запросе. Подзапрос всегда заключен в круглые скобки и обычно выполняется перед основным запросом. Как и любой другой SQL запрос, подзапрос возвращает результирующий набор, который может быть одним из следующих:
- одна строка и один столбец;
- нескольких строк с одним столбцом;
- нескольких строк с несколькими столбцами.

В зависимости от типа результирующего набора подзапроса определяются операторы, которые могут использоваться в основном запросе.

Давайте посмотрим на разные подзапросы. Сначала посмотрим на наших клиентов из таблицы Clusters, у которых доход больше среднего дохода всех клиентов. Для этого нам сначала необходимо определить средний доход, а затем уже сделать фильтрацию. Здесь возможно несколько реализаций.
```sql
SELECT * FROM Clusters
WHERE income > (SELECT AVG(income) from Clusters)
DECLARE @avg_income Float = (SELECT AVG(income) from Clusters)
SELECT * FROM Clusters
WHERE income > @avg_income
```
В первом случае мы использовали подзапрос сразу в блоке WHERE, во втором - объявили переменную, которую потом использовали.

С помощью подзапроса мы можем получить список элементов. Например, давайте выгрузим заказы, которые сделаны покупателями из Germany. Обычно такие задачи решаются через JOIN, и такую реализацию мы посмотрим на следующих занятиях. Чтобы посмотреть заказы покупателей из Германии, нам нужно получить список их ID дополнительным подзапросом.
```sql
SELECT * FROM Orders
WHERE customerid IN (SELECT customerid
FROM Customers
WHERE country='Germany')
```
Подзапрос можно использовать в любой части основного запроса. Допустим нам необходимо стандартизировать (вычесть среднее и разделить на корень из дисперсии) доход клиентов из таблицы Clusters. Тогда с помощью подзапроса можно рассчитать среднее значение и стандартное отклонение, а затем сделать расчет.
```sql
SELECT (income - (SELECT AVG(income) FROM Clusters)) / (SELECT STDEV(income)
FROM Clusters)
FROM Clusters
DECLARE @avg_income FLOAT = (SELECT AVG(income) FROM Clusters)
,@std_income FLOAT = (SELECT STDEV(income) FROM Clusters)
SELECT (income - @avg_income) / @std_income
FROM Clusters
```
Скорее всего, во втором случае, когда мы определили переменные, читаемость нашего скрипта значительно выше.